# 模式
模式在Rust中十分常见。我们在[变量绑定](http://doc.rust-lang.org/nightly/book/variable-bindings.html)，[匹配语句](http://doc.rust-lang.org/nightly/book/match.html)和其它一些地方使用它们。让我们开始一个快速的关于模式可以干什么的教程！

快速回顾：你可以直接匹配常量，并且`_`作为“任何”类型：

```rust
let x = 1;

match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

这会打印出`one`。

## 多重模式（Multiple patterns）
你可以使用`|`匹配多个模式：

```rust
let x = 1;

match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

这会输出`one or two`。

## 范围（Ranges）
你可以用`...`匹配一个范围的值：

```rust
let x = 1;

match x {
    1 ... 5 => println!("one through five"),
    _ => println!("anything"),
}
```

这会输出`one through five`。

范围经常用在整数和`char`上。

```rust
let x = '💅';

match x {
    'a' ... 'j' => println!("early letter"),
    'k' ... 'z' => println!("late letter"),
    _ => println!("something else"),
}
```

这会输出`something else`。

## 绑定
你可以使用`@`把值绑定到名字上：

```rust
let x = 1;

match x {
    e @ 1 ... 5 => println!("got a range element {}", e),
    _ => println!("anything"),
}
```

这会输出`got a range element 1`。在你想对一个复杂数据结构进行部分匹配的时候，这个特性十分有用：

```rust
#[derive(Debug)]
struct Person {
    name: Option<String>,
}

let name = "Steve".to_string();
let mut x: Option<Person> = Some(Person { name: Some(name) });
match x {
    Some(Person { name: ref a @ Some(_), .. }) => println!("{:?}", a),
    _ => {}
}
```

这会输出 `Some("Steve")`，因为我们把Person里面的`name`绑定到`a`。

如果你在使用`|`的同时也使用了`@`，你需要确保名字在每个模式的每一部分都绑定名字：

```rust
let x = 5;

match x {
    e @ 1 ... 5 | e @ 8 ... 10 => println!("got a range element {}", e),
    _ => println!("anything"),
}
```

## 忽略变量（Ignoring variants）
如果你匹配一个带有变量的枚举，你可以用`..`来忽略变量的值和类型：

```rust
enum OptionalInt {
    Value(i32),
    Missing,
}

let x = OptionalInt::Value(5);

match x {
    OptionalInt::Value(..) => println!("Got an int!"),
    OptionalInt::Missing => println!("No such luck."),
}
```

这会输出`Got an int!`。

## 守卫（Guards）
你可以用`if`来引入*匹配守卫*（*match guards*）：

```rust
enum OptionalInt {
    Value(i32),
    Missing,
}

let x = OptionalInt::Value(5);

match x {
    OptionalInt::Value(i) if i > 5 => println!("Got an int bigger than five!"),
    OptionalInt::Value(..) => println!("Got an int!"),
    OptionalInt::Missing => println!("No such luck."),
}
```

这会输出`Got an int!`。

## `ref`和`ref mut`
如果你想要一个引用，使用`ref`关键字：

```rust
let x = 5;

match x {
    ref r => println!("Got a reference to {}", r),
}
```

这会输出`Got a reference to 5`。

这里，`match`中的`r`是`&i32`类型的。换句话说，`ref`关键字创建了一个在模式中使用的引用。如果你需要一个可变引用，`ref mut`同样可以做到：

```rust
let mut x = 5;

match x {
    ref mut mr => println!("Got a mutable reference to {}", mr),
}
```

## 解构（Destructuring）
如果你有一个复合数据类型，例如一个[结构体](http://doc.rust-lang.org/stable/book/structs.html)，你可以在模式中解构它：

```rust
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x: x, y: y } => println!("({},{})", x, y),
}
```

如果你只关心部分值，我们不需要给它们都命名：

```rust
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x: x, .. } => println!("x is {}", x),
}
```

这会输出`x is 0`。

你可以对任何成员进行这样的匹配，不仅仅是第一个：

```rust
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { y: y, .. } => println!("y is {}", y),
}
```

这会输出`y is 0`。

这种“解构”行为可以用在任何复合数据类型上，例如[元组](http://doc.rust-lang.org/nightly/book/primitive-types.html#tuples)和[枚举](http://doc.rust-lang.org/nightly/book/enums.html)

## 混合与匹配（Mix and Match）
(口哨)！根据你的需求，你可以对上面的多种匹配方法进行组合：

```rust
match x {
    Foo { x: Some(ref name), y: None } => ...
}
```

模式十分强大。好好使用它们。
